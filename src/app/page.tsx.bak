'use client';

import { useState } from 'react';

import ClaimsList from '@/components/ClaimsList';
import { SearchResult, ClaimsResponse } from '@/types';

interface RelevantChunk {
  text: string;
  similarity: number;
}

interface ProcessingMetrics {
  totalClaims: number;
  successfulSearches: number;
  failedSearches: number;
  successfulExtractions: number;
  failedExtractions: number;
  errors: Array<{
    claim: string;
    stage: 'search' | 'extraction';
    error: string;
  }>;
}

export default function Home() {
  const [url, setUrl] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isAnalyzingClaims, setIsAnalyzingClaims] = useState(false);
  const [result, setResult] = useState<{ url: string; content: string } | null>(null);
  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
  const [claims, setClaims] = useState<ClaimsResponse | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [metrics, setMetrics] = useState<ProcessingMetrics | null>(null);

  const analyzeClaims = async (content: string) => {
    try {
      setIsAnalyzingClaims(true);
      setMetrics(null); // Reset metrics
      
      // Step 1: Extract claims
      const response = await fetch('/api/claims', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ content }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to analyze claims');
      }
      
      const data = await response.json();
      setClaims(data);
      
      // Initialize metrics
      const initialMetrics: ProcessingMetrics = {
        totalClaims: data.claims?.length || 0,
        successfulSearches: 0,
        failedSearches: 0,
        successfulExtractions: 0,
        failedExtractions: 0,
        errors: []
      };
      setMetrics(initialMetrics);
      
      // Step 2: Perform web search and fact-checking for the claims
      const searchResults = await searchClaims(data, url);
      console.log('Web search results:', searchResults);

      // Get the aggregate trust score from the first search result
      const aggregateTrustScore = searchResults?.[0]?.aggregateTrustScore || 0;

      // Update search metrics (operate on SearchResult[])
      const successCount = Array.isArray(searchResults)
        ? searchResults.filter((r: SearchResult) => !!(r && (r.url || r.content))).length
        : 0;
      const failCount = Array.isArray(searchResults)
        ? (searchResults.length - successCount)
        : 0;
      
      const searchMetrics = {
        successfulSearches: successCount,
        failedSearches: failCount,
        successfulExtractions: successCount, // Since we're now doing extraction in one go
        failedExtractions: failCount,
        errors: (Array.isArray(searchResults) ? searchResults : [])
          .map((result: SearchResult, index: number) => ({
            claim: data.claims?.[index]?.claim || `Claim ${index + 1}`,
            stage: 'search' as const,
            error: result && (result.url || result.content) ? '' : 'No search results found'
          }))
          .filter((item: { error: string }) => item.error)
      };
      
      // Update metrics
      setMetrics({
        ...initialMetrics,
        ...searchMetrics
      });
      
      // Persist results in state
      setSearchResults(searchResults);
      const enrichedClaims = { 
        ...data, 
        searchResults, 
        aggregateTrustScore 
      };
setClaims(enrichedClaims);
      
      return enrichedClaims;
  } catch (error) {
    console.error('Error analyzing claims:', error);
    throw error;
  } finally {
    setIsAnalyzingClaims(false);
  }
};

  const handleAnalyze = async () => {
  if (!url.trim()) {
    setError('Please enter a URL');
    return;
  }
  
  setIsLoading(true);
  setError(null);
  setResult(null);
  setClaims(null);
  
  try {
    // 1. First, fetch and extract content
    const response = await fetch('/api/analyze', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ url: url.trim() }),
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to analyze URL');
    }
    
    const data = await response.json();
    setResult(data);
    
    // 2. Then analyze claims from the extracted content
    const claimsData = await analyzeClaims(data.content);
    setClaims(claimsData);
    
  } catch (error) {
    console.error('Error:', error);
    setError(error instanceof Error ? error.message : 'An unknown error occurred');
  } finally {
    setIsLoading(false);
  }
};

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleAnalyze();
    }
  };

  const searchClaims = async (claimsData: ClaimsResponse, originalUrl: string) => {
    try {
      // 1. Get search results
      const searchResponse = await fetch('/api/websearch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          claims: claimsData.claims,
          search_date: claimsData.search_date,
          originalUrl: originalUrl
        }),
      });
      
      if (!searchResponse.ok) {
        throw new Error('Failed to search claims');
      }
      
      const { urls } = await searchResponse.json();
      if (!urls || !urls.length) return [];

      // 2. Extract content from search results
      const analyzeResponse = await fetch('/api/analyze/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          urls: urls.filter(Boolean) // Remove any null/undefined URLs
        }),
      });

      if (!analyzeResponse.ok) {
        throw new Error('Failed to analyze search results');
      }

      const { results } = await analyzeResponse.json();
      
      // 3. Prepare and log fact-checking request
      const factCheckRequest = {
        claims: claimsData.claims.map((claim, index) => ({
          claim: claim.claim,
          content: results[index]?.content || ''
        }))
      };
      
      console.log('Sending to /api/factCheck:', JSON.stringify({
        claimsCount: factCheckRequest.claims.length,
        sampleClaim: factCheckRequest.claims[0]
      }, null, 2));
      
      // 4. Perform fact-checking and get results with average trust score
      const factCheckResponse = await fetch('/api/factCheck', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(factCheckRequest),
      });

      if (!factCheckResponse.ok) {
        throw new Error('Failed to fact-check results');
      }

      const { results: factCheckResults, averageTrustScore } = await factCheckResponse.json();
      
      // Merge fact-check results into search results (by index, fallback by claim text)
      const merged: SearchResult[] = results.map((result: SearchResult, index: number) => {
        const fc = (Array.isArray(factCheckResults) && (factCheckResults[index] ||
                  factCheckResults.find((r: { claim?: string }) => r?.claim === claimsData.claims?.[index]?.claim))) || undefined;
        return {
          ...result,
          relevantChunks: result.relevantChunks || [],
          verdict: fc?.Verdict,
          reference: fc?.Reference,
          trustScore: typeof fc?.Trust_Score === 'number' ? fc.Trust_Score : undefined,
        } as SearchResult;
      });
      
      // Add the average trust score to the first result
      if (merged.length > 0) {
        merged[0].aggregateTrustScore = averageTrustScore;
      }
      
      return merged;
    } catch (error) {
      console.error('Error in search, analyze, and fact-check:', error);
      return [];
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-200 p-4">
      <div className="w-full max-w-2xl px-4 sm:px-6">
        <div className="text-center mb-12">
          <h1 className="text-5xl font-black text-black mb-4 tracking-tight">
            LUMOS
          </h1>
          <p className="text-gray-800 max-w-md mx-auto text-lg">
            Analyze links for potential misinformation
          </p>
        </div>
        
        <div className="bg-white p-8 rounded-none border-2 border-black shadow-[8px_8px_0_0_rgba(0,0,0,1)]">
          <div className="flex flex-col sm:flex-row gap-3 w-full">
            <div className="relative flex-1">
              <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                <svg className="h-5 w-5 text-black" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                </svg>
              </div>
              <input
          </div>
          <input
            type="text"
            placeholder="Paste your link here..."
            className="w-full pl-10 pr-4 py-4 border-2 border-black rounded-none focus:outline-none focus:ring-0 focus:border-black transition-all duration-200 font-mono placeholder-gray-500 text-black bg-white"
            value={url}
            onChange={(e) => setUrl(e.target.value)}
            onKeyDown={handleKeyDown}
            disabled={isLoading}
          />
                    {searchResults.filter((r) => !!r?.content).length} / {claims.claims.length}
                  </div>
                </div>
                <div className="p-2 bg-gray-100 border border-gray-300 rounded col-span-2 md:col-span-2">
                  <div className="text-gray-800">Verdicts</div>
                  <div className="flex flex-wrap gap-2 mt-1">
                    <span className="text-xs bg-green-100 text-green-800 px-2 py-0.5 rounded">
                      Support: {searchResults.filter((r) => r?.verdict === 'Support').length}
                    </span>
                    <span className="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded">
                      Partially: {searchResults.filter((r) => r?.verdict === 'Partially Support').length}
                    </span>
                    <span className="text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded">
                      Unclear: {searchResults.filter((r) => r?.verdict === 'Unclear').length}
                    </span>
                    <span className="text-xs bg-red-100 text-red-800 px-2 py-0.5 rounded">
                      Contradict: {searchResults.filter((r) => r?.verdict === 'Contradict').length}
                    </span>
                    <span className="text-xs bg-red-100 text-red-800 px-2 py-0.5 rounded">
                      Refute: {searchResults.filter((r) => r?.verdict === 'Refute').length}
                    </span>
                  </div>
                </div>
                <div className="p-2 bg-blue-50 border border-blue-300 rounded">
                  <div className="text-gray-800">Avg. Trust Score</div>
                  <div className="text-2xl font-extrabold text-blue-700">
                    {claims.aggregateTrustScore ?? 0}
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
        
        <div className="mt-16 grid grid-cols-1 md:grid-cols-3 gap-6 text-center">
          {['REAL-TIME ANALYSIS', 'SOURCE VERIFICATION', 'BIAS DETECTION'].map((feature) => (
            <div key={feature} className="bg-white border-2 border-black p-6 hover:shadow-[4px_4px_0_0_rgba(0,0,0,1)] transition-all duration-200">
              <div className="h-12 w-12 border-2 border-black rounded-none flex items-center justify-center mx-auto mb-4">
                <svg className="h-6 w-6 text-black" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="square" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
              </div>
              <span className="text-sm font-bold tracking-wider text-gray-800">{feature}</span>
            </div>
          ))}
        </div>

        {claims && <ClaimsList 
                      claims={claims} 
                      searchResults={claims?.searchResults} 
                    />}
      </div>
    </div>
  );
}